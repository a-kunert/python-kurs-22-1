\section{Den Schleifenfluss kontrollieren  \\ \footnotesize \texttt{break}, \texttt{continue} und \texttt{else}}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{break}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{break} auf, so wird die weitere Abarbeitung der Schleife abgebrochen. Die Ausführung wird mit dem Code \emph{nach} dem Schleifenblock ausgeführt. 		
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
	\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
print("fertig")
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
print("fertig")
# 1 2 3 4 
# fertig
\end{minted}
\end{overprint}

\end{exampleblock}

	
\end{fragile}



\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{continue}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{continue} auf, so wird der aktuelle Schleifendurchgang abgebrochen. Die Ausführung wird mit der nächsten Schleifeniteration fortgesetzt. 
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
# 1 3 5 7 9 
\end{minted}
\end{overprint}
\end{exampleblock}
	
	
\end{fragile}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Der \texttt{else}-Block einer Schleife}
Analog zum \py{if}-Statement, kann auch eine Schleife einen \py{else}-Block haben. Dieser wird ausgeführt, wenn die Schleife \emph{regulär} (also nicht durch die Verwendung von \py{break}) beendet wird.  
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\begin{minted}{python}
name = input("Dein Name: ")

for letter in name: 
  if letter == "a" or letter == "A":
    print("Dein Name enthält ein A")
    break
else: 
  print("Dein Name enthält kein A")
\end{minted}
\end{exampleblock}
	
	
\end{fragile}



\begin{fragile}[Übungen]

\begin{block}{Zählen bis zur nächsten 10er-Zahl}
	\vspace{2pt}
Lies eine Zahl \pybw{x} ein und gib auf der Konsole die Zahlen von \pybw{x} bis zur nächsten 10er-Zahl aus. 
\\
Ist die Eingabe \pybw{x = 17}, so soll die Ausgabe wie folgt aussehen: 

\console{17}\\
\console{18}\\
\console{19}\\
\console{20}
\end{block}
	
\vspace{12pt}
\pause 

\begin{block}{Zählen mit Lücken}
	\vspace{2pt}
	Schreibe ein Skript, dass die Zahlen von 1 bis 99 aufzählt, dabei allerdings die 10er-Zahlen weglässt. Verwende dabei ein \pybw{continue}-Statement.
\end{block}
\end{fragile}

\begin{frame}<beamer:0>[fragile]{Lösungen}

\begin{solutionblock}{Zählen bis zur nächsten 10er-Zahl}
\begin{minted}{python}
x = input("Gib eine Zahl an: ")
x = int(x)

for k in range(x, x + 11):
  print(k)
  if k % 10 == 0:
    break
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Zählen mit Lücken}
\begin{minted}{python}
for k in range(1, 100):
  if k % 10 == 0:
    continue
  print(k)
\end{minted}
\end{solutionblock}

\end{frame}

\begin{fragile}[Übung]
\begin{block}{Quizfrage mit Ausstiegsmöglichkeit}
\vspace{2pt}
Schreibe ein Programm, dass solange nach einer Hauptstadt Deiner Wahl fragt, bis die richtige Antwort eingegeben wird. Wird allerdings der Buchstabe \pybw{q} eingegeben, so bricht das Programm ab. 

\vspace{12pt}

\begin{solutionblock}{Quizfrage mit Ausstiegsmöglichkeit}
\begin{minted}{python}
answer = input("Was ist die Hauptstadt von Frankreich?")
while answer != "Paris": 
  print("Das war leider falsch, versuch es gleich nochmal")
  answer = input("")
  if answer == "q": 
    break
else: 
  print("Das war richtig!")
\end{minted}
\end{solutionblock}
\end{block}
\end{fragile}




\begin{fragile}[Harte Übung]
\begin{block}{Primzahltest}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein und überprüfe, ob diese Zahl eine Primzahl ist. Die Ausgabe des Programms soll etwa wie folgt aussehen:  

\console{Die Zahl 28061983 ist eine Primzahl.}
\end{block}

\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
x = input("Gib eine Zahl ein: ")
x = int(x)

for k in range(2, x):
  if x % k == 0:
    print(f"{x} ist keine Primzahl.")
    break
else:
  print(f"{x} ist eine Primzahl.")
\end{minted}
\end{solutionblock}

\end{fragile}



\section{Listen \\ \footnotesize Viele Variablen gleichzeitig speichern}


\begin{frame}
\begin{block}{Problemstellung}
\vspace{2pt}
Lies mit Hilfe einer Schleife nach und nach Ländernamen ein. 
Alle Länder sollen dabei gespeichert werden. Danach sollst Du die Möglichkeit haben, das soundsovielte Land anzeigen lassen zu können.   

\vspace{8pt}

Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}{}
\begin{block}{Lösung \footnotesize(fast)}
\begin{minted}{python}
# ...
# Um das Eingaben der Länder kümmern wir uns noch 
countries = ["Deutschland", "Frankreich", "Italien", "Spanien"] 

index = input("Das wievielte Land möchtest Du nocheinmal anschauen?")
index = int(index)

print(f"Das { index }. Land ist { countries[index] }")
\end{minted}
\end{block}
\end{fragile}


\begin{fragile}

\metroset{block=fill}
\begin{block}{Struktur einer \emph{Liste}}
\vspace{2pt}
\large
\texttt{my\_list = }\pause {\Large\texttt{[}}\pause 
\texttt{element\_0}\pause,
\pause 
\texttt{element\_1}, \pause 
 \dots   
, \texttt{element\_n}\pause \Large{\texttt{]}}
\end{block}

\pause 

Die Variable \py{my_list} trägt nicht nur einen Wert, sondern $n+1$ Werte. Ansonsten verhält sich \py{my_list} wie eine ganz \enquote{normale} Variable. 
Als Einträge einer Liste sind beliebige Werte mit beliebigen Datentypen zugelassen. 


\vspace{12pt}

\pause

\textbf{Frage:} Welchen Datentyp hat die Liste \py{[2, 2.3, "Hello"]} ? 
	
\end{fragile}

\begin{frame}
	
\begin{block}{Auf Listenelemente zugreifen}
	
\vspace{2pt}

Auf das \pybw{n}-te Element der Liste \py{my_list} kann man mittels \py{my_list[n]} zugreifen. 

\pause 

Mit \py{my_list[-1]}, \py{my_list[-2]}, etc. kann man auf das letzte, vorletzte, etc. Element 
der Liste zugreifen. 

\end{block}

\pause 
\vspace{12pt}

\begin{alertblock}{Achtung}
\vspace{2pt}
Python fängt bei 0 an zu zählen. D.h. das erste Element in der Liste hat den Index 0. \\
Beispiel: \py{my_list[1]} liefert das \textbf{2. Element} der Liste. 
\end{alertblock}

	
\end{frame}	


\begin{frame}
\begin{block}{Schreibzugriff auf Listenelemente}
\vspace{2pt}
Nach dem gleichen Prinzip lassen sich einzelne Listeneinträge verändern. \\
Beispiel: \py{my_list[3] = "Albanien"}. 
\end{block}

\pause 
\vspace{12pt}



\begin{alertblock}{Achtung}
\vspace{2pt}
Man kann nur schon existierende Listeneinträge verändern. 
\end{alertblock}

\pause 
\vspace{12pt}

\end{frame}


\begin{frame}
\begin{block}{Listeneinträge hinzufügen}
	\vspace{2pt}
	Mit der \emph{Methode} \pybw{.append()} kann ein Eintrag zur Liste hinzugefügt werden. \\ 
	Bsp: \py{my_list.append("Russland")} fügt den String \py{"Russland"} zu der Liste hinzu. 
\end{block}	

\pause 
\vspace{12pt}


\begin{block}{Listeneinträge entfernen}
	\pause 
\vspace{2pt}
Mit dem Keyword \pybw{del} kann man Einträge an einer bestimmten Position löschen. Dabei verschieben sich die darauffolgenden Einträge um \pybw{1} nach vorne. \\
Beispiel: \py{del my_list[2]} löscht das dritte Element.  

\pause 

Mit der Methode \pybw{.remove()} kann man Einträge mit einem bestimmten Wert löschen. \\
Beispiel: \py{my_list.remove("Italien")} entfernt den ersten Eintrag mit dem Wert \py{"Italien"}. Ist der Wert nicht vorhanden gibt es eine Fehlermeldung. 
\end{block}
\end{frame}

\begin{fragile}[Übung]
\begin{block}{Eine Liste erstellen}
\vspace{2pt}
Schreibe ein kleines Programm, dass Dich ca. 4x nach einem Land fragt, das Du besucht hast und Dir am Ende die Liste der besuchten Länder ausgibt. 	
\end{block}
\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
countries = []
for k in range(1, 5):
  country = input("Wo warst Du schonmal im Urlaub? ")
  countries.append(country)
print(countries)
\end{minted}
\end{solutionblock}
\end{fragile}





\begin{fragile}[Übung]
\begin{block}{Das Eingangsproblem}
\vspace{2pt}
Schreibe ein kleines Programm, dass solange Namen von Ländern einliest, bis Du \textbf{q} drückst. Danach sollst Du die Möglichkeit haben, eine Zahl \pybw{k} einzugeben, so dass das  \pybw{k}-te Land angezeigt wird. 
\end{block}	
\end{fragile}

\begin{frame}<beamer:0>[fragile]{Lösung}
\begin{solutionblock}{Das Eingangsproblem}
\begin{minted}{python}
countries = []
while True:
  country = input("Gib ein Land ein: ")
  if country == "q":
    break
  countries.append(country)

index = input("Das wievielte Land möchtest Du nochmal anschauen?")
index = int(index)
print(f"Das { index }. Land ist { countries[index-1] }.")
\end{minted}
\end{solutionblock}
\end{frame}

\begin{frame}
\begin{block}{Mutability}

\vspace{2pt}
Listen sind der erste Datentyp, den wir kennenlernen, der \emph{mutable} (veränderbar) ist. Die bisherigen Datentypen waren \emph{immutable}, d.h. man konnte sie zwar überschreiben, aber nicht verändern. 
\end{block}

\pause 
\vspace{12pt}

\metroset{block=fill}
\begin{block}{Call by Reference vs. Call by Value}
\vspace{2pt}
Enthält die Variable \py{my_list} eine Liste, so speichert Python eigentlich gar nicht die Liste in dieser Variable, sondern nur die Speicheradresse der Liste. 
Dieses vorgehen nennt man auch \emph{Call by Reference}. Bei den Datentypen \py{int} und \py{str} wird stattdessen tatsächlich der Wert der Variable abgespeichert. Dies nennt man \emph{Call by Value}.

\end{block}
\end{frame}

\begin{fragile}[Übung]
\begin{block}{Eine Liste kopieren}
\vspace{2pt}
Definiere die Variable \py{my_list} als die Liste \py{[1,2,3]}. Kopiere die Variable \py{my_list} in die Variable \py{my_list_copy}. Füge einen weiteren Eintrag zu \py{my_list} hinzu. Welchen Wert hat \py{my_list_copy}? 
\end{block}
\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
my_list = [1, 2, 3]
my_list_copy = my_list
my_list.append(4)
print(my_list_copy) # 1 2 3 4 
\end{minted}
\end{solutionblock}
\end{fragile}



\begin{fragile}
\begin{block}{Schleife über Liste}
\vspace{2pt}
Analog wie über Strings und Ranges kann man Schleifen auch über eine Liste laufen lassen.  
\end{block}
\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
countries = ["Bulgarien", "Griechenland", "Türkei", "Libanon"]

for country in countries:
  print(country)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
countries = ["Bulgarien", "Griechenland", "Türkei", "Libanon"]

for country in countries:
  print(country)
  
# Bulgarien
# Griechenland
# Türkei
# Libanon
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}


\begin{fragile}
\begin{block}{Schleife über Liste mit Indizes}
\vspace{2pt}
Möchte man in einer Schleife nicht nur die Listeneinträge, sondern auch die Indizes verwenden, so muss man die Funktion \py{enumerate()} auf die Liste anwenden. 
\end{block}
\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
countries = ["Guatemala", "Nicaragua", "Honduras", "Belize"]

for (index, country) in enumerate(countries):
  print(f"Das {index + 1}. Land ist {country}")
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
countries = ["Guatemala", "Nicaragua", "Honduras", "Belize"]

for (index, country) in enumerate(countries):
  print(f"Das {index + 1}. Land ist {country}")

# Das 1. Land ist Guatemala
# Das 2. Land ist Nicaragua
# Das 3. Land ist Honduras
# Das 4. Land ist Belize
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}


\begin{frame}{Übung}

\begin{block}{Liste durchsuchen}
	\vspace{2pt}
Prüfe, ob in einer Liste von Ländern das Land \py{"Italien"} vorkommt. Gib dazu auf der Konsole entweder 

\console{Italien ist in der Liste}

oder 

\console{Italien ist nicht in der Liste}

aus.  

\end{block}
\end{frame}


\begin{frame}<beamer:0>[fragile]{Lösung}
\begin{solutionblock}{Liste durchsuchen}
\begin{minted}{python}
# Wähle ein Beispiel für countries
countries = ["Finnland", "Norwegen", "Schweden", "Dänemark"]

for country in countries:
  if country == "Italien":
    print("Italien ist in der Liste")
    break
else: 
  print("Italien ist nicht in der Liste")
\end{minted}
\end{solutionblock}
\end{frame}

\begin{fragile}

\begin{block}{Ist ein Element in einer Liste enthalten?}
\vspace{2pt}	
Möchte man prüfen, ob ein Element in einer Liste enthalten ist, so kann man auch das Schlüsselwort \py{in} verwenden. 
\end{block}

\pause 
\vspace{12pt}

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
countries = ["Finnland", "Norwegen", "Schweden", "Dänemark"]

var_1 = "Finnland" in countries
var_2 = "Deutschland" in countries

print(var_1)  
print(var_2)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
countries = ["Finnland", "Norwegen", "Schweden", "Dänemark"]

var_1 = "Finnland" in countries
var_2 = "Deutschland" in countries

print(var_1)  # True
print(var_2)  # False
\end{minted}
\end{overprint}

\end{exampleblock}
\end{fragile}


\begin{fragile}
	
\begin{block}{Eine Liste sortieren}
\vspace{2pt}
Um eine Liste zu sortieren, verwende die Methode \pybw{.sort()}. Dies verändert die Liste dauerhaft. \\
\pause 
Um eine sortierte Kopie einer Liste zu erstellen, verwende die Funktion \pybw{sorted()}.  \\
\pause 
Mit Hilfe des Parameters \pybw{reverse=True} lässt sich eine Liste absteigend ordnen. 
\end{block}	

\pause \vspace{12pt}

\begin{exampleblock}{Beispiel für \texttt{sort}}
\vspace{2pt}
\begin{overprint}
\onslide<4|handout:0>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
my_list.sort()
print(my_list)  
\end{minted}
\onslide<5-|handout:1>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
my_list.sort()
print(my_list)  # [1, 2, 5, 7]
\end{minted}
\end{overprint}

\end{exampleblock}

\vspace{12pt}

\pause \pause 

\begin{exampleblock}{Beispiel für \texttt{sorted}}
\vspace{2pt}
\begin{overprint}
\onslide<6|handout:0>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
sorted_list = sorted(my_list)
print(my_list)  
print(sorted_list)  
\end{minted}
\onslide<7|handout:1>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
sorted_list = sorted(my_list)
print(my_list)  # [1, 5, 2, 7]
print(sorted_list)  # [1, 2, 5, 7]
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}

\begin{fragile}
\begin{exampleblock}{Beispiel für absteigende Sortierung}
\vspace{2pt}
\begin{overprint}
\onslide<1|handout:0>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
my_list.sort(reverse=True)
print(my_list)  

my_list = [7, 12, 5, 18]
sorted_list = sorted(my_list, reverse=True)
print(sorted_list) 
\end{minted}
\onslide<2|handout:1>
\begin{minted}{python}
my_list = [1, 5, 2, 7]
my_list.sort(reverse=True)
print(my_list)  # [7, 5, 2, 1]

my_list = [7, 12, 5, 18]
sorted_list = sorted(my_list, reverse=True)
print(sorted_list) # [18, 12, 7, 5] 
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}


\begin{fragile}[Übung]
	
\begin{block}{Beste/Schlechteste Note}
\vspace{2pt}
Sei \py{grades} eine Liste der Noten deiner letzten Klausuren (z.B. \py{grades = [12, 9, 14, 11]}). 
Gib dann auf der Konsole einmal die beste und einmal die schlechteste Note aus. 
\end{block}	

\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
grades = [12, 9, 14, 11]
grades.sort()
min_grade = grades[0]
max_grade = grades[-1]
print(f"Schlechteste Note: {min_grade}")
print(f"Beste Note: {max_grade}")
\end{minted}
\end{solutionblock}
\end{fragile}

\begin{fragile}
\begin{block}{Nützliche Funktionen/Methoden}
\vspace{2pt}	
Für Listen stellt Python viele nützliche Methoden bzw. Funktionen bereit. Wenn Du googlest, findest Du für viele \enquote{Alltagsfragen} eine Lösung. 

Zum Beispiel hier: \texttt{https://docs.python.org/3/tutorial/datastructures.html}
\end{block}

\pause
\vspace{12pt}


\begin{exampleblock}{Beispiele}
\begin{minted}{python}
my_list = [2, 4, 8, 1]

len(my_list)   # = 4  (Gibt die Anzahl der Elemente an)
sum(my_list)   # = 15 (Berechnet die Summe der Elemente)
my_list.reverse() # [1, 8, 4, 2] (Dreht die Reihenfolge um)
my_list.insert(2,-1) # [2, 4, -1, 8, 1] (fügt den Wert -1 an Position 2 ein)
my_list.pop() # 1 (Gibt den letzten Eintrag der Liste zurück und entfernt ihn aus der Liste)
\end{minted}
\end{exampleblock}
\end{fragile}


\begin{fragile}[Übung]

\begin{block}{Durchschnittsnote}
\vspace{2pt}
Sei \py{grades} wieder eine Liste mit deinen letzten Noten.  Gib auf der Konsole die Durchschnittsnote aus. 
\end{block}	

\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
grades = [12, 9, 14, 11]
total_sum = sum(grades)
count = len(grades)
average = total_sum/count
print(f"Die Durchschnittsnote ist {average}")
\end{minted}
\end{solutionblock}
	
\end{fragile}

\begin{frame}
\begin{block}{Slicing}
\vspace{2pt}
Wenn man eine Liste hat, ist es oft nötig, einen Teil der Liste \enquote{auszuschneiden}.\\
\pause
Dafür hat Python die \emph{Slice-Notation} eingeführt. \\
\pause 
Diese funktioniert nach folgendem Schema: 

\pause  \py{my_list[start:stop:step]}. 

\pause 
Die Einträge (start, stop, step) sind dabei jeweils optional. Wie immer wird der obere Wert (\pybw{stop}) gerade nicht erreicht.  
\pause 


Slicing lässt sich übrigens auch nach dem gleichen Schema auch auf Strings anwenden. 
\end{block}	

\pause
\vspace{12pt}

\begin{alertblock}{Wichtig}
\vspace{2pt}
Wenn man Slicing anwendet, erhält man eine Kopie der ausgewählten Elemente zurück. Die ursprüngliche Liste wird \emph{nicht} verändert. 
\end{alertblock}
\end{frame}


\begin{fragile}
\begin{exampleblock}{Beispiele}
	\vspace{2pt}
\begin{overprint}
\onslide<1|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]    
my_list[0:4]     
my_list[1:1]     
my_list[0:4:2]   
my_list[:3]      
my_list[2:]      
my_list[:]      
my_list[1:-2]    
my_list[-3:-1]  
my_list[::-1]    
\end{minted}

\onslide<2|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     
my_list[1:1]     
my_list[0:4:2]   
my_list[:3]      
my_list[2:]     
my_list[:]       
my_list[1:-2]   
my_list[-3:-1]  
my_list[::-1]    
\end{minted}

\onslide<3|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     
my_list[0:4:2]   
my_list[:3]      
my_list[2:]      
my_list[:]       
my_list[1:-2]    
my_list[-3:-1]  
my_list[::-1]    
\end{minted}

\onslide<4|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   
my_list[:3]      
my_list[2:]     
my_list[:]       
my_list[1:-2]    
my_list[-3:-1]   
my_list[::-1]    
\end{minted}


\onslide<5|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   
my_list[:3]      
my_list[2:]      
my_list[:]       
my_list[1:-2]    
my_list[-3:-1]   
my_list[::-1]    
\end{minted}

\onslide<6|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      
my_list[2:]      
my_list[:]       
my_list[1:-2]    
my_list[-3:-1]   
my_list[::-1]    
\end{minted}

\onslide<7|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      
my_list[:]       
my_list[1:-2]   
my_list[-3:-1]   
my_list[::-1]    
\end{minted}

\onslide<8|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      # [6, 8, 10]
my_list[:]       
my_list[1:-2]    
my_list[-3:-1]  
my_list[::-1]    
\end{minted}

\onslide<9|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      # [6, 8, 10]
my_list[:]       # [2, 4, 6, 8, 10]
my_list[1:-2]    
my_list[-3:-1]   
my_list[::-1]    
\end{minted}

\onslide<10|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      # [6, 8, 10]
my_list[:]       # [2, 4, 6, 8, 10]
my_list[1:-2]    # [6]
my_list[-3:-1]    
my_list[::-1]     
\end{minted}

\onslide<11|handout:0>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      # [6, 8, 10]
my_list[:]       # [2, 4, 6, 8, 10]
my_list[1:-2]    # [6]
my_list[-3:-1]   # [6, 8] 
my_list[::-1]     
\end{minted}

\onslide<12|handout:1>
\begin{minted}{python}
my_list = [2, 4, 6, 8, 10]

my_list[1:3]     # [4, 6]
my_list[0:4]     # [2, 4, 6, 8]
my_list[1:1]     # []
my_list[0:4:2]   # [2, 6]
my_list[:3]      # [2, 4, 6]
my_list[2:]      # [6, 8, 10]
my_list[:]       # [2, 4, 6, 8, 10]
my_list[1:-2]    # [6]
my_list[-3:-1]   # [6, 8] 
my_list[::-1]    # [10, 8, 6, 4, 2]  
\end{minted}

\end{overprint}
\end{exampleblock}
\end{fragile}


\section{Dictionaries}

\begin{frame}
\begin{block}{Problemstellung}
\vspace{2pt}
Eine Variable soll nicht nur die Namen von Ländern enthalten, sondern auch noch deren Hauptstadt. 

\vspace{8pt}

Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}{}
\begin{block}{Lösung}
	\begin{minted}{python}
	capitals = {"Deutschland": "Berlin", "Spanien": "Madrid", "Italien": "Rom"}
	
	country = input("Von welchem Land möchtest Du die Hauptstadt wissen?")
	
	print(f"Die Hauptstadt von { country } ist { capitals[country] } Punkte")
	\end{minted}
\end{block}
\end{fragile}

\begin{fragile}
	
	\metroset{block=fill}
	\begin{block}{Struktur eines \emph{Dictionaries}}
		\vspace{2pt}
		\large
		\texttt{my\_dict = }\pause {\Large\texttt{\{}}\pause 
		\texttt{key\_1}\pause\texttt{:}\pause\texttt{value\_1}\pause,
		\pause 
		\texttt{key\_2:value\_2}, \pause 
		\dots   
		, \texttt{key\_n:value\_n}\pause \Large{\texttt{\}}}
	\end{block}
	\pause 
	
	Das \emph{Dictionary} \py{my_dict} enthält Schlüssel-Wert-Paare (\emph{key-value-pairs}). Die Schlüssel müssen eindeutig und unveränderlich sein (z.B. vom Typ \pybw{string} oder \pybw{int}). Die Werte dürfen beliebige Datentypen sein. 
	
\end{fragile}

\begin{fragile}

\begin{block}{Good to know}
	\pause
\begin{itemize}[<+->]
\item Zur besseren Übersichtlichkeit werden Dictionaries oftmals wie folgt formatiert: 
\begin{minted}{python}
capitals = { 
  "Deutschland": "Berlin", 
  "Spanien": "Madrid", 
  "Italien": "Rom"
}
\end{minted}
\item Dictionaries sind mutable, können also verändert werden. 
\item Dictionaries besitzen keine vernünftige Anordnung und können nicht geordnet werden. 
\item Ein Dictionary kann leer sein. 
\end{itemize}
\end{block}
\end{fragile}

\begin{fragile}
\begin{itemize}
\item Oftmals bietet es sich an, statt einem Dictionary eine Liste von Dictionaries zu verwenden:
\begin{minted}{python}
countries = [
  { 
    "name": "Deutschland", 
    "capital": "Berlin",
    "pop": 82000000,
    "is_eu_member": True
  },
  # ... 
  {
    "name": "Italien",
    "capital": "Rom", 
    "pop": 65000000,
    "is_eu_member": True
  }
]
\end{minted}
\end{itemize}
\end{fragile}



\begin{frame}


\begin{block}{Auf Dictionary-Elemente zugreifen}
	
	\vspace{2pt}
	
	Sei \py{my_dict = {"a": 5, "b": 8}}.
	
	\pause
	
	Mit der Syntax \py{my_dict["a"]} kann man den Wert an der Stelle \py{"a"} auslesen. 
	
	\pause 
	
	Mit der Syntax \py{my_dict["a"] = 12} kann  man einzelne Werte des Dictionaries verändern. 
	
	\pause 
	
	Auf diese Weise können auch ganz neue Paare hinzugefügt werden. Zum Beispiel: \py{my_dict["c"] = -2}. 
\end{block}
\end{frame}


\begin{frame}{Übung}

\begin{block}{Dictionary manipulieren}
	\vspace{2pt}
	Gegeben sei das folgende Dictionary: 
	
	\py{grades = {"Mathe": 8, "Bio": 11, "Sport": 13}} 
	
	Bestimme die Durchschnittsnote dieser drei Fächer. Verbessere danach Deine Mathenote um einen Punkt und füge noch eine weitere Note für Englisch hinzu (Abfrage über Konsole). Gib danach erneut den Durchschnitt an.  
\end{block}

\end{frame}


\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Dictionary manipulieren}
\begin{minted}{python}
grades = {"Mathe": 8, "Bio": 11, "Sport": 13}

grades_sum = grades["Mathe"] + grades["Bio"] + grades["Sport"]
average = grades_sum/len(grades)
print(f"Der Durchschnitt ist {average} Punkte")

grades["Mathe"] += 1

eng_grade = input("Welche Note hast Du in Englisch? ")
eng_grade = int(eng_grade)
grades["Englisch"] = eng_grade

grades_sum += grades["Englisch"]
average = grades_sum/len(grades)
print(f"Der Durchschnitt ist {average} Punkte")
\end{minted}
\end{solutionblock}
\end{frame}



\begin{frame}
\begin{block}{Einen Eintrag aus einem Dictionary entfernen}
\vspace{2pt}
Wie bei Listen, kann man mittels \py{del}-Statement einen Eintrag aus einem Dictionary entfernen: 

\py{del eu_countries["united_kingdom"]}	

\end{block}	



\end{frame}	

\begin{fragile}
\begin{block}{Was wird hier passieren?}
\vspace{2pt}
\begin{minted}{python}
old_capitals = {"Deutschland": "Bonn", "Norwegen": "Oslo"}
new_capitals = old_capitals

new_capitals["Deutschland"] = "Berlin" 

print(old_capitals)
print(new_capitals)
\end{minted}
\end{block}

\pause 
\vspace{12pt}

\begin{block}{Erklärung}
	\vspace{2pt}
Da Dictionaries mutable sind, findet bei ihnen der Aufruf mittels \emph{Call by Reference} statt. Das heißt, dass in der Variable \py{old_capitals} bzw. \py{new_capitals} nicht die Länder gespeichert sind, sondern nur die Speicheradresse, wo die Länder zu finden sind. Ändert man die zugrundeliegenden Daten an einer Stelle, so ändern sie sich daher auch an der anderen Stelle. 
\end{block}


\end{fragile}

\begin{frame}
	\begin{block}{Eine Kopie von einem Dictionary erstellen}
		\vspace{2pt}
		Mit der Funktion \py{dict()} kann man eine Kopie von einem Dictionary erstellen. 
		
		Beispiel: \py{dict(my_dict)} erstellt eine Kopie von \py{my_dict}.
	\end{block}
\end{frame}

\begin{fragile}
\begin{block}{Schleife über Dictionary I}
\vspace{2pt}
Ähnlich wie bei Listen kann man Schleifen auch über ein Dictionary laufen lassen.  
\end{block}
\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for item in capitals:
  print(item)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for item in capitals:
  print(item)

# Litauen
# Lettland
# Tallin
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}

\begin{fragile}
\begin{block}{Schleife über Dictionary II}
\vspace{2pt}
Möchte man in der Schleife nicht nur die Schlüssel, sondern auch die Werte des Dictionaries zur Verfügung haben, so muss man die Methode \py{.items()} auf das Dictionary anwenden.   
\end{block}
\vspace{12pt}
\pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for key, value in capitals.items():
  print(f"Hauptstadt von {key}: {value}")
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for key, value in capitals.items():
  print(f"Hauptstadt von {key}: {value}")

# Hauptstadt von Litauen: Vilnius
# Hauptstadt von Lettland: Riga
# Hauptstadt von Estland: Tallin
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}

\begin{frame}{Übungen}

\begin{block}{Zwei Dictionaries kombinieren}
	\vspace{2pt}
Gegeben seien zwei Dictionaries, z.B.  

\py{eu = {"Deutschland": "Berlin", "Frankreich": "Paris" }}

und 

\py{non_eu = {"Russland": "Moskau", "China": "Peking" }}

Füge die Einträge des zweiten Dictionaries zum ersten Dictionary hinzu. 
\end{block}

\pause 

\vspace{12pt}

\begin{block}{Ein Dictionary \enquote{filtern}}
\vspace{2pt}
Sei ein beliebiges Dictionary mit Noten gegeben. Entferne alle Einträge, deren Note schlechter als 5 Punkte ist. 
\end{block}
\end{frame}


\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Zwei Dictionaries kombinieren}
\begin{minted}{python}
eu = {"Deutschland": "Berlin", "Frankreich": "Paris" }
non_eu = {"Russland": "Moskau", "China": "Peking" }

for key,value in non_eu.items():
  eu[key] = value
print(eu)
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Ein Dictionary \enquote{filtern}}
\begin{minted}{python}
grades = {"Deutsch": 11, "Mathe": 3, "Sport": 14, "Geschichte": 1}
#  Man darf die Länge eines Dictionaries in einer Schleife nicht verändern, deshalb machen wir eine Kopie
result = dict(grades)
for key, value in grades.items():
  if value < 5:
    del result[key]
print(result)
\end{minted}
\end{solutionblock}

\end{frame}


\begin{fragile}

\begin{block}{Ein Dictionary zerlegen}
\vspace{2pt}
Mit der Methode \py{.keys()} erhält man eine Liste aller Schlüssel eines Dictionaries. \pause

Mit der Methode \py{.values()} erhält man eine Liste aller Werte eines Dictionaries. \pause 

In beiden Fällen, muss das Ergebnis mittels der Funktion \py{list()} in eine Liste umgewandelt werden. 
\end{block}


\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<4|handout:0>
\begin{minted}{python}
my_dictionary = {"China": "Peking", "Japan": "Tokio", "Korea": "Seoul"}

countries = my_dictionary.keys()
countries = list(countries)

capitals = my_dictionary.values()
capitals = list(capitals)

print(countries)
print(capitals)
\end{minted}
\onslide<5|handout:1>
\begin{minted}{python}
my_dictionary = {"China": "Peking", "Japan": "Tokio", "Korea": "Seoul"}

countries = my_dictionary.keys()
countries = list(countries)

capitals = my_dictionary.values()
capitals = list(capitals)

print(countries)  # ["China", "Japan", "Korea"]
print(capitals)   # ["Peking", "Tokio", "Seoul"]
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}





