\section{Dictionaries}

\begin{frame}
\begin{block}{Problemstellung}
\vspace{2pt}
Eine Variable soll nicht nur die Namen von Ländern enthalten, sondern auch noch deren Hauptstadt. 

\vspace{8pt}

Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}{}
\begin{block}{Lösung}
	\begin{minted}{python}
	capitals = {"Deutschland": "Berlin", "Spanien": "Madrid", "Italien": "Rom"}
	
	country = input("Von welchem Land möchtest Du die Hauptstadt wissen?")
	
	print(f"Die Hauptstadt von { country } ist { capitals[country] } Punkte")
	\end{minted}
\end{block}
\end{fragile}

\begin{fragile}
	
	\metroset{block=fill}
	\begin{block}{Struktur eines \emph{Dictionaries}}
		\vspace{2pt}
		\large
		\texttt{my\_dict = }\pause {\Large\texttt{\{}}\pause 
		\texttt{key\_1}\pause\texttt{:}\pause\texttt{value\_1}\pause,
		\pause 
		\texttt{key\_2:value\_2}, \pause 
		\dots   
		, \texttt{key\_n:value\_n}\pause \Large{\texttt{\}}}
	\end{block}
	\pause 
	
	Das \emph{Dictionary} \py{my_dict} enthält Schlüssel-Wert-Paare (\emph{key-value-pairs}). Die Schlüssel müssen eindeutig und unveränderlich sein (z.B. vom Typ \pybw{string} oder \pybw{int}). Die Werte dürfen beliebige Datentypen sein. 
	
\end{fragile}

\begin{fragile}

\begin{block}{Good to know}
	\pause
\begin{itemize}[<+->]
\item Zur besseren Übersichtlichkeit werden Dictionaries oftmals wie folgt formatiert: 
\begin{minted}{python}
capitals = { 
  "Deutschland": "Berlin", 
  "Spanien": "Madrid", 
  "Italien": "Rom"
}
\end{minted}
\item Dictionaries sind mutable, können also verändert werden. 
\item Dictionaries besitzen keine vernünftige Anordnung und können nicht geordnet werden. 
\item Ein Dictionary kann leer sein. 
\end{itemize}
\end{block}
\end{fragile}

\begin{fragile}
\begin{itemize}
\item Oftmals bietet es sich an, statt einem Dictionary eine Liste von Dictionaries zu verwenden:
\begin{minted}{python}
countries = [
  { 
    "name": "Deutschland", 
    "capital": "Berlin",
    "pop": 82000000,
    "is_eu_member": True
  },
  # ... 
  {
    "name": "Italien",
    "capital": "Rom", 
    "pop": 65000000,
    "is_eu_member": True
  }
]
\end{minted}
\end{itemize}
\end{fragile}



\begin{frame}


\begin{block}{Auf Dictionary-Elemente zugreifen}
	
	\vspace{2pt}
	
	Sei \py{my_dict = {"a": 5, "b": 8}}.
	
	\pause
	
	Mit der Syntax \py{my_dict["a"]} kann man den Wert an der Stelle \py{"a"} auslesen. 
	
	\pause 
	
	Mit der Syntax \py{my_dict["a"] = 12} kann  man einzelne Werte des Dictionaries verändern. 
	
	\pause 
	
	Auf diese Weise können auch ganz neue Paare hinzugefügt werden. Zum Beispiel: \py{my_dict["c"] = -2}. 
\end{block}
\end{frame}


\begin{frame}{Übung}

\begin{block}{Dictionary manipulieren}
	\vspace{2pt}
	Gegeben sei das folgende Dictionary: 
	
	\py{grades = {"Mathe": 8, "Bio": 11, "Sport": 13}} 
	
	Bestimme die Durchschnittsnote dieser drei Fächer. Verbessere danach Deine Mathenote um einen Punkt und füge noch eine weitere Note für Englisch hinzu (Abfrage über Konsole). Gib danach erneut den Durchschnitt an.  
\end{block}

\end{frame}


\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Dictionary manipulieren}
\begin{minted}{python}
grades = {"Mathe": 8, "Bio": 11, "Sport": 13}

grades_sum = grades["Mathe"] + grades["Bio"] + grades["Sport"]
average = grades_sum/len(grades)
print(f"Der Durchschnitt ist {average} Punkte")

grades["Mathe"] += 1

eng_grade = input("Welche Note hast Du in Englisch? ")
eng_grade = int(eng_grade)
grades["Englisch"] = eng_grade

grades_sum += grades["Englisch"]
average = grades_sum/len(grades)
print(f"Der Durchschnitt ist {average} Punkte")
\end{minted}
\end{solutionblock}
\end{frame}



\begin{frame}
\begin{block}{Einen Eintrag aus einem Dictionary entfernen}
\vspace{2pt}
Wie bei Listen, kann man mittels \py{del}-Statement einen Eintrag aus einem Dictionary entfernen: 

\py{del eu_countries["united_kingdom"]}	

\end{block}	



\end{frame}	

\begin{fragile}
\begin{block}{Was wird hier passieren?}
\vspace{2pt}
\begin{minted}{python}
old_capitals = {"Deutschland": "Bonn", "Norwegen": "Oslo"}
new_capitals = old_capitals

new_capitals["Deutschland"] = "Berlin" 

print(old_capitals)
print(new_capitals)
\end{minted}
\end{block}

\pause 
\vspace{12pt}

\begin{block}{Erklärung}
	\vspace{2pt}
Da Dictionaries mutable sind, findet bei ihnen der Aufruf mittels \emph{Call by Reference} statt. Das heißt, dass in der Variable \py{old_capitals} bzw. \py{new_capitals} nicht die Länder gespeichert sind, sondern nur die Speicheradresse, wo die Länder zu finden sind. Ändert man die zugrundeliegenden Daten an einer Stelle, so ändern sie sich daher auch an der anderen Stelle. 
\end{block}


\end{fragile}

\begin{frame}
	\begin{block}{Eine Kopie von einem Dictionary erstellen}
		\vspace{2pt}
		Mit der Funktion \py{dict()} kann man eine Kopie von einem Dictionary erstellen. 
		
		Beispiel: \py{dict(my_dict)} erstellt eine Kopie von \py{my_dict}.
	\end{block}
\end{frame}

\begin{fragile}
\begin{block}{Schleife über Dictionary I}
\vspace{2pt}
Ähnlich wie bei Listen kann man Schleifen auch über ein Dictionary laufen lassen.  
\end{block}
\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for item in capitals:
  print(item)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for item in capitals:
  print(item)

# Litauen
# Lettland
# Tallin
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}

\begin{fragile}
\begin{block}{Schleife über Dictionary II}
\vspace{2pt}
Möchte man in der Schleife nicht nur die Schlüssel, sondern auch die Werte des Dictionaries zur Verfügung haben, so muss man die Methode \py{.items()} auf das Dictionary anwenden.   
\end{block}
\vspace{12pt}
\pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for key, value in capitals.items():
  print(f"Hauptstadt von {key}: {value}")
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
capitals = {"Litauen": "Vilnius", "Lettland": "Riga", "Estland": "Tallin"}

for key, value in capitals.items():
  print(f"Hauptstadt von {key}: {value}")

# Hauptstadt von Litauen: Vilnius
# Hauptstadt von Lettland: Riga
# Hauptstadt von Estland: Tallin
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}

\begin{frame}{Übungen}

\begin{block}{Zwei Dictionaries kombinieren}
	\vspace{2pt}
Gegeben seien zwei Dictionaries, z.B.  

\py{eu = {"Deutschland": "Berlin", "Frankreich": "Paris" }}

und 

\py{non_eu = {"Russland": "Moskau", "China": "Peking" }}

Füge die Einträge des zweiten Dictionaries zum ersten Dictionary hinzu. 
\end{block}

\pause 

\vspace{12pt}

\begin{block}{Ein Dictionary \enquote{filtern}}
\vspace{2pt}
Sei ein beliebiges Dictionary mit Noten gegeben. Entferne alle Einträge, deren Note schlechter als 5 Punkte ist. 
\end{block}
\end{frame}


\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Zwei Dictionaries kombinieren}
\begin{minted}{python}
eu = {"Deutschland": "Berlin", "Frankreich": "Paris" }
non_eu = {"Russland": "Moskau", "China": "Peking" }

for key,value in non_eu.items():
  eu[key] = value
print(eu)
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Ein Dictionary \enquote{filtern}}
\begin{minted}{python}
grades = {"Deutsch": 11, "Mathe": 3, "Sport": 14, "Geschichte": 1}
#  Man darf die Länge eines Dictionaries in einer Schleife nicht verändern, deshalb machen wir eine Kopie
result = dict(grades)
for key, value in grades.items():
  if value < 5:
    del result[key]
print(result)
\end{minted}
\end{solutionblock}

\end{frame}


\begin{fragile}

\begin{block}{Ein Dictionary zerlegen}
\vspace{2pt}
Mit der Methode \py{.keys()} erhält man eine Liste aller Schlüssel eines Dictionaries. \pause

Mit der Methode \py{.values()} erhält man eine Liste aller Werte eines Dictionaries. \pause 

In beiden Fällen, muss das Ergebnis mittels der Funktion \py{list()} in eine Liste umgewandelt werden. 
\end{block}


\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{overprint}
\onslide<4|handout:0>
\begin{minted}{python}
my_dictionary = {"China": "Peking", "Japan": "Tokio", "Korea": "Seoul"}

countries = my_dictionary.keys()
countries = list(countries)

capitals = my_dictionary.values()
capitals = list(capitals)

print(countries)
print(capitals)
\end{minted}
\onslide<5|handout:1>
\begin{minted}{python}
my_dictionary = {"China": "Peking", "Japan": "Tokio", "Korea": "Seoul"}

countries = my_dictionary.keys()
countries = list(countries)

capitals = my_dictionary.values()
capitals = list(capitals)

print(countries)  # ["China", "Japan", "Korea"]
print(capitals)   # ["Peking", "Tokio", "Seoul"]
\end{minted}
\end{overprint}
\end{exampleblock}
\end{fragile}


\section{Comprehensions}

\begin{frame}
\begin{block}{Typische Manipulationen}
\vspace{2pt}
Sehr häufig möchte man eine Datenstruktur (d.h. eine Liste oder ein Dictionary) basierend auf den Werten manipulieren. Dabei werden vor allem zwei Aspekte immer wieder gebraucht: Maps und Filter. 
\end{block}

\end{frame}

\begin{frame}
\metroset{block=fill}
\begin{block}{Map}
\vspace{2pt}
Ersetzt man jedes Element einer Liste durch ein aus dem ursprünglich berechnetem Element, so spricht man von einer \emph{Map} (bzw. einem Mapping). 
\end{block}

\pause 

\vspace{12pt}

\metroset{block=transparent}
\begin{exampleblock}{Beispiel}
\vspace{2pt}
Gegeben ist die Liste \py{my_list = [2, 5, 3, 12, 7] }. Die Liste soll so manipuliert werden, dass alle Einträge durch ihren doppelten Wert ersetzt werden. 
\end{exampleblock}

\end{frame}

\begin{fragile}
\begin{overprint}

\begin{block}{Traditionelle Lösung}
\vspace{2pt}
\begin{minted}{python}
my_list = [2, 5, 3, 12, 7]
result = []
for k in my_list: 
  result.append(2 * k)
print(result)
\end{minted}
\end{block}

\vspace{12pt}

\pause

\begin{block}{The Pythonian Way}
\vspace{2pt}
\begin{minted}{python}
my_list = [2, 5, 3, 12, 7]
result = [2 * k for k in my_list]
print(result)
\end{minted}
\end{block}
\end{overprint}


\end{fragile}

\begin{frame}
\metroset{block=fill}
\begin{block}{Filter}
\vspace{2pt}
Streicht man Elemente entsprechend ihres Wertes aus einer Liste, so spricht man von einem \emph{Filter}. 
\end{block}

\pause 

\vspace{12pt}

\metroset{block=transparent}
\begin{exampleblock}{Beispiel}
\vspace{2pt}
Gegeben ist die Liste \py{my_list = [2, 5, 3, 12, 7] }. Aus der Liste sollen alle ungeraden Einträge gestrichen werden. 
\end{exampleblock}

\end{frame}

\begin{fragile}
\begin{overprint}

\begin{block}{Traditionelle Lösung}
\vspace{2pt}
\begin{minted}{python}
my_list = [2, 5, 3, 12, 7]
result = []
for k in my_list: 
  if k % 2 == 0: 
    result.append(k)
print(result)
\end{minted}
\end{block}

\vspace{12pt}

\pause

\begin{block}{The Pythonian Way}
\vspace{2pt}
\begin{minted}{python}
my_list = [2, 5, 3, 12, 7]
result = [k for k in my_list if k % 2 == 0]
print(result)
\end{minted}
\end{block}
\end{overprint}


\end{fragile}

\begin{fragile}
\begin{block}{Kombination aus Map und Filter}
\vspace{2pt}
Selbstverständlich können Maps und Filter auch kombiniert werden. 
\end{block}

\vspace{12pt}

\begin{exampleblock}{Beispiel}
\vspace{2pt}
Lösche alle ungeraden Zahlen und verdopple dann alle Zahlen: 

\begin{minted}{python}
my_list = [2, 5, 3, 12, 7]
result = [2 * k for k in my_list if k % 2 == 0]
print(result)
\end{minted}
\end{exampleblock}

\end{fragile}


\begin{fragile}

\begin{block}{Dictionary Comprehension}
\vspace{2pt}
Man kann das gleiche Verfahren auch auf Dictionaries anwenden. Dabei können jeweils key und value für die Maps und Filter verwendet werden. 
\end{block}

\vspace{12pt}

\begin{exampleblock}{Beispiel}
\vspace{2pt}
\begin{minted}{python}
my_dict = {"a": 2, "b": 3}
result = {key: value for (key, value) in my_dict.items()}
print(result)
\end{minted}
\end{exampleblock}

\end{fragile}

\begin{fragile}{Übung}

\begin{block}{List Comprehension}
\vspace{2pt}
Gegeben sei eine beliebige Liste von ganzen Zahlen. Streiche alle Zahlen, die ungerade oder negativ sind. Ersetze die übrigen Zahlen durch ihre Hälfte. 
\end{block}


\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
my_list = [2, -3, 40, 15, 7, 8]
result = [k//2 for k in my_list if k % 2 == 0 and k >= 0]
\end{minted}
\end{solutionblock}

\end{fragile}


\begin{fragile}{Übung}

\begin{block}{List Comprehension}
\vspace{2pt}
Gegeben sei das Dictionary 
\py{{"Mathe": 9, "Sport": 13, "Physik": 4, "Bio": 12}}. 
Lösche nun daraus alle Noten unter 5 Punkte sowie die Sportnote. Zusätzlich soll das Dictionary danach wie folgt aussehen: 
\py{ {"In Mathe": "9 Punkte", "In Bio": "12 Punkte"} }. 

\end{block}


\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
grades = {"Mathe": 9, "Sport": 13, "Physik": 4, "Bio": 12}
result = {
    "In " + key: f"{value} Punkte"
    for (key, value) in grades.items()
    if value >= 5 and key != "Sport"
}
\end{minted}
\end{solutionblock}

\end{fragile}





























\section{Funktionen \\ \footnotesize Wie man Code wiederverwerten kann}
\begin{frame}
\begin{block}{Problemstellung}
	\vspace{2pt}
	Es sei eine Liste mit Temperaturen gegeben: 
	
	\py{temperatures = [22, 18, 20, 15, 12, 7, 5, -2, 4]}
	
	\pause
	Es sollen zunächst Durchschnitte von jeweils der folgenden Grundgesamtheit genommen werden: 
	\begin{itemize}
		\item Alle Werte
		\item Die ersten drei Werte
		\item Jeder zweite Wert
	\end{itemize}
\pause 
	Statt durch eine Zahl, soll das Ergebnis jedoch mit den Worten  
	\begin{itemize}
		\item \py{"Mild"} für Durchschnitte $\geq$ 15 Grad
		\item \py{"Zu kalt"} für Durschnitte $<$ 15 Grad
	\end{itemize}
	abgespeichert werden. 
	\pause 
	\vspace{8pt}
	Wie macht man das \emph{elegant}? 
\end{block}
\end{frame}
\begin{fragile}{}
\begin{block}{Lösung \onslide<8->{\footnotesize (Hauptsache es funktioniert)}}
\vspace{2pt}
\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
   
   














#   
\end{minted}
\onslide<3|handout:0>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
if average >= 5: 
  average = "Mild"
else: 
  average = "Zu kalt"
  
  
  
  
  
  
  
  
  
  
  
  
#  
\end{minted}
\onslide<4|handout:0>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
if average >= 5: 
  average = "Mild"
else: 
  average = "Zu kalt"

average_2 = sum(temperatures[:3]) / len(temperatures[:3])










#
\end{minted}
\onslide<5|handout:0>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
if average >= 5: 
  average = "Mild"
else: 
  average = "Zu kalt"

average_2 = sum(temperatures[:3]) / len(temperatures[:3])
if average_2 >= 5:
  average_2 = "Mild"
else: 
  average_3 = "Zu kalt"






#
\end{minted}
\onslide<6|handout:0>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
if average >= 5: 
  average = "Mild"
else: 
  average = "Zu kalt"

average_2 = sum(temperatures[:3]) / len(temperatures[:3])
if average_2 >= 5:
  average_2 = "Mild"
else: 
  average_3 = "Zu kalt"

average_3 = sum(temperatures[::2]) / len(temperatures[::2])




#
\end{minted}
\onslide<7-|handout:1>
\begin{minted}{python}
average = sum(temperatures) / len(temperatures)
if average >= 5: 
  average = "Mild"
else: 
  average = "Zu kalt"

average_2 = sum(temperatures[:3]) / len(temperatures[:3])
if average_2 >= 5:
  average_2 = "Mild"
else: 
  average_3 = "Zu kalt"

average_3 = sum(temperatures[::2]) / len(temperatures[::2])
if average_3 < 5:
  average_3 = "Zu kalt"
else: 
  average_3 = "Mild"
#
\end{minted}
\end{overprint}
\end{block}
\end{fragile}

\begin{frame}
\begin{block}{Nachteile dieser Lösung}
	\pause 
	\begin{itemize}[<+->]
	\item Viel Schreibarbeit, viel Wiederholung
	\item Der Code ist schwierig zu lesen. Man sieht vor lauter Wiederholungen nicht, was passiert. 
	\item Jedes Mal, wenn man diese \enquote{Berechnungslogik} verwendet, könnte man einen (Tipp-)Fehler machen.  
	\item Wenn man das Anforderungsprofil minimal ändert, muss diese \enquote{Logik} bei \emph{jedem} Auftreten im Code geändert werden
		(z.B. statt \py{"Mild"} soll das Ergebnis \py{"Warm"} heißen). In echten Projekten, kann das schnell ein paar Hundert Male sein. 	
	\end{itemize}
\end{block}
\end{frame}

\begin{fragile}
\begin{block}{Bessere Lösung}
\begin{minted}{python}
def compute_average(temp_list):
  result = sum(temp_list) / len(temp_list)
  if result >= 5:
    result = "Mild"
  else: 
    result = "Zu kalt"
  return result

average = compute_average(temperatures)
average_2 = compute_average(temperatures[:3])
average_3 = compute_average(temperatures[::2])
\end{minted}
\end{block}

\end{fragile}

\begin{frame}
\metroset{block=fill}
\begin{block}{Definition: Funktion}
\vspace{2pt}
Eine Funktion ist ein Codeblock, der nur ausgeführt wird, wenn die Funktion \emph{aufgerufen} wird. 
Man kann der Funktion Werte als \emph{Parameter} übergeben. 
Sie kann auch einen Wert als Ergebnis \emph{zurückgeben}. 
\end{block}

\pause 

\vspace{12pt}
Man kann sich eine Funktion wie eine Maschine vorstellen, wo man oben Dinge (=Parameter) hineinfüllt und unten ein Ergebnis (=Rückgabewert) herausbekommt. 
Unabhängig von dem Eingabe-Ausgabe-Prinzip, kann solch eine Maschine auch Nebeneffekte (z.B. Krach) produzieren. 

\pause 

\vspace{12pt}
Man unterscheidet zwischen \emph{Definition} und \emph{Ausführung} einer Funktion. 
\end{frame}



\begin{frame}
\metroset{block=fill}


\renewcommand{\baselinestretch}{1.5}
\begin{block}{Struktur der Funktions-Definition}	
\vspace{2pt}

\pause 

\texttt{def} \pause \textit{Funktionsname}\pause\texttt{(}\pause\textit{Parameter\_0}\pause, \textit{Parameter\_1}, \dots, \textit{Parameter\_n}\pause\texttt{)}\pause\texttt{:}\\
\pause \spacechar \spacechar \textit{Codezeile1} \\
\pause \spacechar \spacechar \textit{Codezeile2} \\
\pause \phantom{Code} \vdots \\
\pause \spacechar \spacechar \texttt{return} \textit{Ergebnis}
\end{block}
\renewcommand{\baselinestretch}{1}
\vspace{12pt}

\pause 

\begin{block}{Struktur eines Funktionsaufrufs}	
\vspace{2pt}
result = \textit{Funktionsname}\texttt{(}\textit{Argument\_0}, \textit{Argument\_1}, \dots, \textit{Argument\_n}\texttt{)}
\end{block}

\end{frame}


\begin{frame}

\begin{block}{Good to know}
\pause 
\begin{itemize}[<+->]
	\item Eine Funktion muss schon \emph{vor} dem ersten Aufruf definiert worden sein (das ist nicht in allen Sprachen so). 
	\item Die Eingabwerte nennt man in der Funktionsdefintion \emph{Parameter}, beim Aufruf der Funktion nennt man sie jedoch \emph{Argumente}.
	\item Nicht jede Funktion braucht Eingangsdaten. Die Liste von Parametern einer Funktion kann daher leer sein.   
	\item Beim Aufruf spielt die Reihenfolge der angegebenen Argumente eine entscheidene Rolle. Sie werden entsprechend der Reihenfolge den Parametern in der Definition zugeordnet. 
%	\item Den Rückgabewert der Funktion erhält man durch den Zuweisungsoperator (\py{=}).
	\item Eine Funktion muss nicht unbedingt etwas zurückgeben, d.h. das \py{return}-Statement ist optional.
	\item Das \py{return}-Statement muss nicht unbedingt am Schluss der Funktion stehen. Jedoch wird Code, der nach dem \py{return}-Statement kommt, nicht mehr ausgeführt. 
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Übungen}

\begin{block}{Funktion ohne Parameter}
	\vspace{2pt}
Schreibe eine Funktion, die Deinen Namen auf der Konsole ausgibt. 
\end{block}
\vspace{12pt}
\begin{block}{Funktion mit einem Parameter}
\vspace{2pt}
Schreibe eine Funktion, die die übergebene Zahl verdoppelt. 
\end{block}
\vspace{12pt}
\begin{block}{Funktion mit zwei Parametern}
\vspace{2pt}
Schreibe eine Funktion, die die beiden übergebenen Zahlen multipliziert. 
\end{block}
\vspace{12pt}
\begin{block}{Funktion ohne Rückgabewert}
\vspace{2pt}
Was gibt eine Funktion zurück, die kein \py{return}-Statement enthält?
\end{block}
\end{frame}

\begin{frame}<beamer:0>[fragile]{Lösungen}

\begin{solutionblock}{Funktion ohne Parameter}
\begin{minted}{python}
def my_name(): 
  print("Aaron Kunert")
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Funktion mit einem Parameter}
\begin{minted}{python}
def double(number): 
  return number * 2
\end{minted}
\end{solutionblock}

\vspace{12pt}

\begin{solutionblock}{Funktion mit zwei Parametern}
\begin{minted}{python}
def multiply(number1,number2): 
  return number1 * number2
\end{minted}
\end{solutionblock}


\end{frame}

\begin{frame}{Übung}
\begin{block}{Aggregatzustand von Wasser}
\vspace{2pt}
Schreibe eine Funktion, die entsprechend der übergebenen Temperatur den Aggregatzustand von Wasser (\py{"fest"},\py{"flüssig"},\py{"gasförmig"}) als String zurückgibt. 

Schaffst Du es ohne die Schlüsselwörter \py{elif} und \py{else}? 
\end{block}
\end{frame}

\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Aggregatzustand von Wasser}
\begin{minted}{python}
def get_state(temp):
  if temp < 0:
    return "fest"
  if temp > 100:
    return "gasförmig"
  return "flüssig"
\end{minted}
\end{solutionblock}

\end{frame}


\begin{fragile}[Komplexere Übung]

\begin{block}{Gewichtete Durschnittsnote}
	\vspace{2pt}
Schreibe eine Funktion, die eine Liste der folgenden Struktur erwartet: 

\begin{minted}{python}
grades = [ 
  { 
    "subject": "Deutsch", 
    "grade": 14,
    "is_major": True
  },
  # ... 
  {
    "subject": "Sport",
    "grade": 11, 
    "is_major": False
  }
]
\end{minted}

Berechne die Durchschnittsnote, wobei Hauptfächer doppelt gewichtet werden sollen. 
\end{block}

\end{fragile}

\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Gewichtete Durchschnittsnote}
\begin{minted}{python}
def weighted_average(grades): 
  weighted_sum = 0
  weighted_length = 0
  for grade in grades: 
    if grade["is_major"]: 
      weighted_sum += 2 * grade["grade"]
      weighted_length += 2
    else:
      weighted_sum += grade["grade"]
      weighted_length += 1
  result = weighted_sum/weighted_length
  return result 
\end{minted}
\end{solutionblock}

\end{frame}


\begin{fragile}

\begin{block}{Optionale Parameter}
	
	\pause 
	
\vspace{2pt}
Manchmal wirst Du bei Funktionen bemerken, dass einige der Parameter fast immer den gleichen Wert haben. In diesem Fall, möchtest Du diese Parameter nicht bei jedem Aufruf immer hinschreiben, sondern nur dort, wo er vom Standardfall abweicht. Dies ist möglich, wenn man den Standardwert (\emph{default value}) bei der Definition mit angibt. 

\pause 

\textbf{Wichtig:} Bei der Definition müssen die optionalen Parameter immer hinter den Pflichtparametern stehen.
\end{block}

\vspace{12pt}
\pause 

\begin{exampleblock}{Beispiel}
\begin{minted}{python}
def double(number, factor=2): 
  return number * factor
\end{minted} 


\pause 

Diese Funktion ist sehr vielseitig: Im einfachen Fall verdoppelt sie die eingegebene Zahl. Optional lässt sich der Faktor aber beliebig verändern. 
\end{exampleblock}

\end{fragile}


\begin{frame}
\begin{block}{Typischer Einsatzbereich}
\vspace{2pt}
Oftmals merkt man im Verlauf eines Projektes, dass eine gegebene Funktion nicht flexibel genug ist, dann kann man sie um einen optionalen Parameter erweitern, ohne den bisherigen Code verändern zu müssen. 
\end{block}

\vspace{12pt}

\pause 

\begin{exampleblock}{Fiktives Beispiel}
\vspace{2pt}
Stell Dir vor, Du baust einen Rechner für Deine Endnote. Hauptfachnoten werden immer doppelt gewichtet, daher verwendest Du die Funktion \py{weighted_average}, wie in der Übung. Plötzlich kommt raus, dass in der Abschlussprüfung, Hauptfächer vierfach gewichtet werden. Also erweiterst Du die Funktion, so dass der Gewichtungsfaktor anpassbar ist.

\pause

Jedoch möchtest Du den bisherigen Code nicht verändern. Daher definierst Du den Gewichtungsfaktor als optionalen Parameter, so dass die Funktion \enquote{abwärtskompatibel} zu ihrer bisherigen Verwendung ist.

\pause 
Die Definition startet dann mit \py{def weighted_average(grades, weight=2):} 
 
\end{exampleblock}

\end{frame}

\begin{frame}{Übung}

\begin{block}{Flexibler Durchschnittsrechner}
\vspace{2pt}
Erweitere die Funktion zur Berechnung von gewichteten Durchschnittsnoten so, dass optional der Gewichtungsfaktor angegeben werden kann. 	
\end{block}

\end{frame}

\begin{frame}<beamer:0>[fragile]{Lösung}

\begin{solutionblock}{Flexibler Durchschnittsrechner}
\begin{minted}{python}
def weighted_average(grades, weight=2): 
  weighted_sum = 0
  weighted_length = 0
  for grade in grades: 
    if grade["is_major"]: 
      weighted_sum += weight * grade["grade"]
      weighted_length += weight
    else:
      weighted_sum += grade["grade"]
      weighted_length += 1
  result = weighted_sum/weighted_length
  return result 
\end{minted}
\end{solutionblock}

\end{frame}

\begin{fragile}
	
\begin{block}{Named Parameters}
\vspace{2pt}
Hat eine Funktion viele Parameter, von denen etliche optional sind, so kann man einen Parameter statt über die Reihenfolge auch über den Namen übergeben. 
\end{block}

\pause 
\vspace{12pt}

\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{minted}{python}
def my_function(parameter1, parameter2=0, parameter3="x", parameter4=-17):
  # ... 
\end{minted}
Möchte man jetzt die Funktion mit einem eigenen Wert \pybw{parameter1} und \pybw{parameter4} aufrufen aber alles andere auf Standard lassen, so geht das wie folgt: 

\py{my_function(15, parameter4=-20)}
\end{exampleblock}

	
\end{fragile}










